##page 9
4、“.ibd”文件和ibdata 文件
这两种文件都是存放Innodb 数据的文件，之所以有两种文件来存放Innodb 的数据
（包括索引），是因为Innodb 的数据存储方式能够通过配置来决定是使用
共享表空间存放存储数据，还是独享表空间存放存储数据。
独享表空间存储方式使用“.ibd”文件来存放数据，且每个表一个“.ibd”文件，
文件存放在和MyISAM 数据相同的位置。如果选用共享存储表空
间来存放数据，则会使用ibdata 文件来存放，所有表共同使用一个
（或者多个，可自行配置）ibdata 文件。ibdata 文件可以通过innodb_data_home_dir 
和innodb_data_file_path两个参数共同配置组成，
 innodb_data_home_dir 配置数据存放的总目录， 而
innodb_data_file_path 配置每一个文件的名称。当然， 也可以不配置
innodb_data_home_dir 而直接在innodb_data_file_path 参数配置的时候使用绝对路径来
完成配置。innodb_data_file_path 中可以一次配置多个ibdata 文件。文件可以是指定大
小，也可以是自动扩展的，但是Innodb 限制了仅仅只有最后一个ibdata 文件能够配置成自
动扩展类型。当我们需要添加新的ibdata 文件的时候，只能添加在innodb_data_file_path
配置的最后，而且必须重启MySQL 才能完成ibdata 的添加工作。不过如果我们使用独享表
空间存储方式的话，就不会有这样的问题，但是如果要使用裸设备的话，每个表一个裸设备，
可能造成裸设备数量非常大，而且不太容易控制大小，实现比较困难，而共享表空间却不会
有这个问题，容易控制裸设备数量。我个人还是更倾向于使用独享表空间存储方式。当然，
两种方式各有利弊，看大家各自应用环境的侧重点在那里了。
上面仅仅介绍了两种最常用存储引擎的数据文件，此外其他各种存储引擎都有各自的数
据文件，读者朋友可以自行创建某个存储引擎的表做一个简单的测试，做更多的了解。

2.1.3 Replication相关文件
1、master.info 文件：
master.info 文件存在于Slave 端的数据目录下，里面存放了该Slave 的Master 端的
相关信息，包括Master 的主机地址，连接用户，连接密码，连接端口，当前日志位置，已
经读取到的日志位置等信息。

2、relay log 和relay log index
mysql-relay-bin.xxxxxn 文件用于存放Slave 端的I/O 线程从Master 端所读取到
的Binary Log 信息，然后由Slave 端的SQL 线程从该relay log 中读取并解析相应的
日志信息，转化成Master 所执行的SQL 语句，然后在Slave 端应用。
mysql-relay-bin.index 文件的功能类似于mysql-bin.index ，同样是记录日志的存
放位置的绝对路径，只不过他所记录的不是Binary Log，而是Relay Log。
3、relay-log.info 文件：
类似于master.info，它存放通过Slave 的I/O 线程写入到本地的relay log 的相关信
息。供Slave 端的SQL 线程以及某些管理操作随时能够获取当前复制的相关信息。

#p23
另外MyISAM 的B-Tree 索引有一个较
大的限制，那就是参与一个索引的所有字段的长度之和不能超过1000 字节。

MyISAM 的数据存放格式是分为静态（FIXED）固
定长度、动态（DYNAMIC）可变长度以及压缩（COMPRESSED）这三种格式

只要表中有可变长度类型的字段存在，那么该表就肯定是DYNAMIC 格式的，如果没有任何可变长度的字段，
则为FIXED 格式


MyISAM 存储引擎的表是否足够可靠呢？在MySQL 用户参考手册中列出在遇到如下情况
的时候可能会出现表文件损坏：
1、当mysqld 正在做写操作的时候被kill 掉或者其他情况造成异常终止；
2、主机Crash；
3、磁盘硬件故障；
4、MyISAM 存储引擎中的bug？
##检查表
check table api_dhl

READ UNCOMMITTED，
READ COMMITTED，
REPEATABLE READ 
SERIALIZABLE

2、数据多版本读取
Innodb 在事务支持的同时，为了保证数据的一致性已经并发时候的性能，通过对undo
信息，实现了数据的多版本读取。

3、锁定机制的改进
Innodb 改变了MyISAM 的锁机制，实现了行锁。虽然Innodb 的行锁机制的实现是通过
索引来完成的，但毕竟在数据库中99%的SQL 语句都是要使用索引来做检索数据的。所以，
行锁定机制也无疑为Innodb 在承受高并发压力的环境下增强了不小的竞争力


一种是共享表空间，通过innodb_data_file_path 来指定，
另外一种是独享表空间，也就是每个表的数据和索引被存放在一个
单独的.ibd 文件中。

一个参数（skip-innodb）来屏蔽MySQL 中的Innodb
存储引擎，这样即使我们在安装编译的时候将Innodb 存储引擎安装进去了，使用者也无法
创建Innodb 的表


/etc/services

#p52 mysql备份
通过mysqldump 生成INSERT 语句的逻辑备份文件的时候，有一个非常有用的选项可
以供我们使用，那就是“--master-data[=value]”。当添加了“--master-data=1”的时候，
mysqldump 会将当前MySQL 使用到binlog 日志的名称和位置记录到dump 文件中，并且是被
以CHANGE_MASTER 语句的形式记录，如果仅仅只是使用“--master-data”或者“--masterdata＝
2”，则CHANGE_MASTER 语句会以注释的形式存在。这个选项在实施slave 的在线搭建
的时候是非常有用的，即使不是进行在线搭建slave，也可以在某些情况下做恢复的过程中
通过备份的binlog 做进一步恢复操作。
在某些场景下，我们可能只是为了将某些特殊的数据导出到其他数据库中，而又不希望
通过先建临时表的方式来实现，我们还可以在通过mysqldump 程序的“—where='wherecondition'”
来实现，但只能在仅dump 一个表的情况下使用。

，通过“--no-createinfo”
去掉dump 文件中创建表结构的命令等等


通过"FIELDS TERMINATED BY"可以设定每两个字段之间的分隔符；
而通过“LINES TERMINATED BY”则会告诉MySQL 输出文件在每条记录结束的时候需要
添加什么字符。

SELECT * from Table INTO OUTFILE '/tmp/dump.text'
-> FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
-> LINES TERMINATED BY '\n'
-> FROM test_outfile limit 100;

导出逗号的
mysqldump -uroot -T/tmp/mysqldump test test_outfile --fieldsenclosed-
by=\" --fields-terminated-by=,

mysql优化
##p77
MySQL 的 Query Profiler 是一个使用非常方便的 Query 诊断分析工具，
通过该工具可以获取一条Query 在整个执行过程中多种资源的消耗情况，
如 CPU，IO，IPC，SWAP 等，以及发生的 PAGE FAULTS，CONTEXT SWITCHE 等等，
同时还能得到该 Query 执行过程中 MySQL 所调用的各个函数在源文件中的位置。


##p89
锁定类型					说明
IGNORE					当发生锁请求的时候内部交互使用，在锁定结构和队列中并不会有任何信息存储
UNLOCK					释放锁定请求的交互用所类型
READ					普通读锁定
WRITE					普通写锁定
READ_WITH_SHARED_LOCKS  在Innodb 中使用到，由如下方式产生 如：SELECT ... LOCK IN SHARE MODE
READ_HIGH_PRIORITY		高优先级读锁定
READ_NO_INSERT			不允许Concurent Insert 的锁定
WRITE_ALLOW_WRITE		这个类型实际上就是当由存储引擎自行处理锁定的时候，mysqld 允许其他的线程再获取读或者写锁定，因为即使资源冲突，存储引擎自己也会知道怎么来处理
WRITE_ALLOW_READ		这种锁定发生在对表做DDL（ALTER TABLE ...）的时候，MySQL 可以允许其他线程获取读锁定，因为MySQL 是通过重建整个表然后再RENAME 而实现的该功能，所在整个过程原表仍然可以提供读服务
WRITE_CONCURRENT_INSERT 正在进行Concurent Insert 时候所使用的锁定方式，该锁定进行的时候，除了READ_NO_INSERT 之外的其他任何读锁定请求都不会被阻塞
WRITE_DELAYED			在使用INSERT DELAYED 时候的锁定类型
WRITE_LOW_PRIORITY		显示声明的低级别锁定方式， 通过设置LOW_PRIORITY_UPDAT = 1 而产生
WRITE_ONLY				当在操作过程中某个锁定异常中断之后系统内部需要进行CLOSE TABLE 操作，在这个过程中出现的锁定类型就是WRITE_ONLY




###p125
mysql索引限制
1）myisam索引键值的长度不能超过1000字节
2）blob text类型的列目前只支持前缀索引
3）mysql目前不支持函数索引
4）使用！使用无法使用索引
5）过滤字段使用了函数后无法使用索引
6）join条件字段的类型不一致时无法使用索引
7）使用like开始无法使用索引
8)使用非等值mysql无法使用hash索引


##p162
show VARIABLES like '%binlog%'
+-----------------------------------------+----------------------+
| Variable_name                           | Value                |
+-----------------------------------------+----------------------+
| binlog_cache_size                       | 32768                |
| binlog_direct_non_transactional_updates | OFF                  |
| binlog_format                           | MIXED                |
| innodb_locks_unsafe_for_binlog          | OFF                  |
| max_binlog_cache_size                   | 18446744073709547520 |
| max_binlog_size                         | 1073741824           |
| sync_binlog                             | 0                    |
+-----------------------------------------+----------------------+

“sync_binlog”：这个参数是对于MySQL 系统来说是至关重要的，他不仅影响到Binlog 对MySQL 所
带来的性能损耗，而且还影响到MySQL 中数据的完整性。对于“sync_binlog”参数的各种设置的说明如
下：
● sync_binlog=0，当事务提交之后，MySQL 不做fsync 之类的磁盘同步指令刷新binlog_cache 中
的信息到磁盘，而让Filesystem 自行决定什么时候来做同步，或者cache 满了之后才同步到磁
盘。
● sync_binlog=n，当每进行n 次事务提交之后，MySQL 将进行一次fsync 之类的磁盘同步指令来
将binlog_cache 中的数据强制写入磁盘


MySQL 复制环境中，实际上是是有8 个参数可以让我们控制需要复制或者需要忽略而不进行复制的DB 或
者Table 的，分别为：
● Binlog_Do_DB：设定哪些数据库（Schema）需要记录Binlog；
● Binlog_Ignore_DB：设定哪些数据库（Schema）不要记录Binlog；
● Replicate_Do_DB：设定需要复制的数据库（Schema），多个DB 用逗号（“,”）分隔；
● Replicate_Ignore_DB：设定可以忽略的数据库（Schema）；
● Replicate_Do_Table：设定需要复制的Table；
● Replicate_Ignore_Table：设定可以忽略的Table；
● Replicate_Wild_Do_Table：功能同Replicate_Do_Table，但可以带通配符来进行设置；
● Replicate_Wild_Ignore_Table：功能同Replicate_Ignore_Table，可带通配符设置；

这八个参数中的前面两个是设置在Master 端的，而后面六个参数则是设置在Slave 端
的。虽然前面两个参数和后面六个参数在功能上并没有非常直接的关系，但是对于优化MySQL 的
Replication 来说都可以启到相似的功能。当然也有一定的区别，其主要区别如下：

##Slow Query Log 的相关参数配置。
show variables like 'log_slow%';
##
show variables like 'long_query%';

MySQL 中针对Query Cache 有两个专
用的SQL Hint（提示）：SQL_NO_CACHE 和SQL_CACHE，分别代表强制不使用Query Cache 和强制使用
Query Cache。



##p167 网络连接的性能配置项及对性能的影响
 ● max_conecctions：整个MySQL允许的最大连接数； 
       这个参数主要影响的是整个MySQL应用的并发处理能力，当系统中实际需要的连接量大于 
       max_conecctions的情况下，由于MySQL的设置限制，那么应用中必然会产生连接请求的等待， 
       从而限制了相应的并发量。所以一般来说，只要MySQL主机性能允许，都是将该参数设置的尽 
       可能大一点。一般来说500到800左右是一个比较合适的参考值 

   ● max_user_connections：每个用户允许的最大连接数； 
       上面的参数是限制了整个MySQL的连接数，而max_user_connections则是针对于单个用户的连 
       接限制。在一般情况下我们可能都较少使用这个限制，只有在一些专门提供MySQL数据存储服 
       务，或者是提供虚拟主机服务的应用中可能需要用到。除了限制的对象区别之外，其他方面和 
       max_connections一样。这个参数的设置完全依赖于应用程序的连接用户数，对于普通的应用来
 说，完全没有做太多的限制，可以尽量放开一些。 

   ● net_buffer_length：网络包传输中，传输消息之前的netbuffer初始化大小； 
       这个参数主要可能影响的是网络传输的效率，由于该参数所设置的只是消息缓冲区的初始化大 
       小，所以造成的影响主要是当我们的每次消息都很大的时候MySQL总是需要多次申请扩展该缓 
       冲区大小。系统默认大小为16KB，一般来说可以满足大多数场景，当然如果我们的查询都是非 
       常小，每次网络传输量都很少，而且系统内存又比较紧缺的情况下，也可以适当将该值降低到 
       8KB。 

   ● max_allowed_packet：在网络传输中，一次传消息输量的最大值； 
       这个参数与net_buffer_length相对应，只不过是netbuffer的最大值。当我们的消息传输量 
       大于net_buffer_length的设置时，MySQL会自动增大net buffer的大小，直到缓冲区大小达 
       到max_allowed_packet所设置的值。系统默认值为1MB，最大值是1GB，必须设定为1024的倍 
       数，单位为字节。 

   ● back_log：在MySQL的连接请求等待队列中允许存放的最大连接请求数。 
       连接请求等待队列，实际上是指当某一时刻客户端的连接请求数量过大的时候，MySQL主线程没 
       办法及时给每一个新的连接请求分配（或者创建）连接线程的时候，还没有分配到连接线程的 
       所有请求将存放在一个等待队列中，这个队列就是MySQL的连接请求队列。当我们的系统存在 
       瞬时的大量连接请求的时候，则应该注意back_log参数的设置。系统默认值为50，最大可以设 
       置为65535。当我们增大back_log的设置的时候，同时还需要主义OS级别对网络监听队列的限 
       制，因为如果OS的网络监听设置小于MySQL的back_log设置的时候，我们加大“back_log”设 
       置是没有意义的。 

在MySQL中，为了尽可提高客户端请求创建连接这个过程的性能，实现了一个ThreadCache池，将 
空闲的连接线程存放在其中，而不是完成请求后就销毁。这样，当有新的连接请求的时候，MySQL首先会 
检查ThreadCache池中是否存在空闲连接线程，如果存在则取出来直接使用，如果没有空闲连接线程， 
才创建新的连接线程。在MySQL中与连接线程相关的系统参数及状态变量说明如下：
● thread_cache_size：ThreadCache池中应该存放的连接线程数。 
       当系统最初启动的时候，并不会马上就创建thread_cache_size所设置数目的连接线程存放在 
       ThreadCache池中，而是随着连接线程的创建及使用，慢慢的将用完的连接线程存入其中。当 
       存放的连接线程达到thread_cache_size值之后，MySQL就不会再续保存用完的连接线程了。 

       如果我们的应用程序使用的短连接，ThreadCache池的功效是最明显的。因为在短连接的数据 
       库应用中，数据库连接的创建和销毁是非常频繁的，如果每次都需要让MySQL新建和销毁相应 
       的连接线程，那么这个资源消耗实际上是非常大的，而当我们使用了ThreadCache之后，由于 
       连接线程大部分都是在创建好了等待取用的状态，既不需要每次都重新创建，又不需要在使用 
       完之后销毁，所以可以节省下大量的系统资源。所以在短连接的应用系统中， 
       thread_cache_size的值应该设置的相对大一些，不应该小于应用系统对数据库的实际并发请求 
       数。 

 ● thread_stack：每个连接线程被创建的时候，MySQL给他分配的内存大小。 
       当MySQL创建一个新的连接线程的时候，是需要给他分配一定大小的内存堆栈空间，以便存放 
       客户端的请求Query以及自身的各种状态和处理信息。不过一般来说如果不是对MySQL的连接线 
       程处理机制十分熟悉的话，不应该轻易调整该参数的大小，使用系统的默认值（192KB）基本上 
       可以所有的普通应用环境。如果该值设置太小，会影响MySQL连接线程能够处理客户端请求的 
       Query内容的大小，以及用户创建的Procedures和Functions等。 

mysql>show variables like'thread%';

+---------------------------------+---------------------------+

| Variable_name                   | Value                     |

+---------------------------------+---------------------------+

| thread_cache_size               | 100                       |

| thread_concurrency              | 10                        |

| thread_handling                 | one-thread-per-connection |

| thread_pool_high_prio_mode      | transactions              |

| thread_pool_high_prio_tickets   | 4294967295                |

| thread_pool_idle_timeout        | 60                        |

| thread_pool_max_threads         | 100000                    |

| thread_pool_oversubscribe       | 10                        |

| thread_pool_size                | 24                        |

| thread_pool_stall_limit         | 30                        |

| thread_stack                    | 262144                    |

| threadpool_workaround_epoll_bug | OFF                       |

+---------------------------------+---------------------------+

再来看一下系统被连接的次数以及当前系统中连接线程的状态值： 
mysql>show status like'connections';

+-------------------------+-----------------+

| Variable_name           | Value           |

+-------------------------+-----------------+

| Connections             | 8216212         |系统启动到现在共接收到客户端的连接次数

+-------------------------+-----------------+

mysql>show status like'%thread%';

+------------------------------------------------+-----------------+

| Variable_name                                  | Value           |

+------------------------------------------------+-----------------+

| Delayed_insert_threads                         | 0               |

| Extra_threads_connected                        | 0               |

| Performance_schema_thread_classes_lost         | 0               |

| Performance_schema_thread_instances_lost       | 0               |

| Slow_launch_threads                            | 0               |

| Threadpool_idle_threads                        | 0               |

| Threadpool_threads                             | 0               |

| Threads_cached                                 | 68              | 而在ThreadCache池中当共Cache了个连接线程。

| Threads_connected                              | 33              | 当前有33个连接线程处于和客户端连接的状态

| Threads_created                                | 187             | 共创建了187个连接线程

| Threads_rejected                               | 0               |

| Threads_running                                | 13              | 而33个连接状态的线程中只有一个13是active状态，

| Tokudb_FILESYSTEM_THREADS_BLOCKED_BY_FULL_DISK | 0               |

+------------------------------------------------+-----------------+

Threads_Cache_Hit= (Connections-Threads_created)/Connections*100% 
（8216212-187）/8216212=0.9999772401198995

mysql>show status like'open_tables'

+-------------------------+-----------------+

| Variable_name           | Value           |

+-------------------------+-----------------+

| Open_tables             | 100             |

+-------------------------+-----------------+

##p172
在MySQL中，之前介绍的多种Cache之外，还有在Query执行过程中的两种Buffer会对数据库的整 
体性能产生影响。 
mysql>show variables like'%buffer%';

+-------------------------------------+-----------------+

| Variable_name                       | Value           |

+-------------------------------------+-----------------+

| bulk_insert_buffer_size             | 4194304         |

| innodb_buffer_pool_dump_at_shutdown | OFF             |

| innodb_buffer_pool_dump_now         | OFF             |

| innodb_buffer_pool_filename         | ib_buffer_pool  |

| innodb_buffer_pool_instances        | 8               |

| innodb_buffer_pool_load_abort       | OFF             |

| innodb_buffer_pool_load_at_startup  | OFF             |

| innodb_buffer_pool_load_now         | OFF             |

| innodb_buffer_pool_size             | 10066329600     |

| innodb_change_buffer_max_size       | 25              |

| innodb_change_buffering             | all             |

| innodb_log_buffer_size              | 8388608         |

| innodb_sort_buffer_size             | 1048576         |

| join_buffer_size                    | 1048576         |  当我们的Join 是 ALL，index，rang 或者 index_merge 的时候使用的Buffer； 

| key_buffer_size                     | 16777216        |

| myisam_sort_buffer_size             | 262144          |

| net_buffer_length                   | 16384           |

| preload_buffer_size                 | 32768           |

| read_buffer_size                    | 1048576         |

| read_rnd_buffer_size                | 1048576         |

| sort_buffer_size                    | 2097152         |

| sql_buffer_result                   | OFF             |

+-------------------------------------+-----------------+

###p175 常用的存储引擎优化
我们先来分析一下与MyISAM索引缓存相关的几个系统参数和状态参数
◆ key_buffer_size，索引缓存大小； 
       这个参数用来设置整个MySQL中的常规 KeyCache大小。一般来说，如果我们的MySQL是运行 
   在32位平台纸上，此值建议不要超过2GB大小。如果是运行在64位平台纸上则不用考虑此限制，但 
   也最好不要超过4GB。 

   ◆ key_buffer_block_size，索引缓存中的CacheBlockSize； 
       在前面我们已经介绍了，在Key Cache中的所有数据都是以Cache Block的形式存在，而 
       key_buffer_block_size就是设置每个Cache Block的大小，实际上也同时限定了我们将 
       “.MYI”文件中的IndexBlock被读入时候的FileBlock的大小。 

   ◆ key_cache_division_limit，LRU链表中的HotArea和WarmArea分界值； 
       实际上，在MySQL的KeyCache中所使用的LRU算法并不像传统的算法一样仅仅只是通过访问频 
       率以及最后访问时间来通过一个唯一的链表实现，而是将其分成了两部分。一部分用来存放使 
       用比较频繁的Hot CackeLock（HotChain），被成为HotArea，另外一部分则用来存放使用 
       不是太频繁的WarmCacheBlock（WarmChain），被成为WarmArea。这样做的目的主要是为 
       了保护使用比较频繁的CacheBlock更不容易被换出。而key_cache_division_limit参数则是 
       告诉MySQL该如何划分整个CacheChain划分为HotChain和WarmChain两部分，参数值为Warm 
       Chain占整个Chain的百分比值。设置范围1～100，系统默认为100，也就是只有WarmChain。 

   ◆ key_cache_age_threshold，控制CacheBlock从HotArea降到WarmArea的限制； 
       key_cache_age_threshold参数控制HotArea中的CacheBlock何时该被降级到WarmArea中。 
       系统默认值为300，最小可以设置为100。值越小，被降级的可能性越大。 


   Key_Size =key_number* (key_length+4)/0.67 

   Max_key_buffer_size<Max_RAM-QCache_Usage-Threads_Usage-System_Usage 

   Threads_Usage  =  max_connections  *  (sort_buffer_size  +  join_buffer_size  + 
read_buffer_size+read_rnd_buffer_size+thread_stack) 

Cache相关的性能状态参数变量。 

   ◆ Key_blocks_not_flushed，已经更改但还未刷新到磁盘的DirtyCacheBlock； 
   ◆ Key_blocks_unused，目前未被使用的CacheBlock数目； 
   ◆ Key_blocks_used，已经使用了的CacheBlock数目； 
   ◆ Key_read_requests，CacheBlock被请求读取的总次数； 
   ◆ Key_reads，在CacheBlock中找不到需要读取的Key信息后到“.MYI”文件中读取的次数； 
   ◆ Key_write_requests，CacheBlock被请求修改的总次数； 
   ◆ Key_writes，在CacheBlock中找不到需要修改的Key信息后到“.MYI”文件中读入再修改的次 
       数； 

Key_buffer_UsageRatio = (1 - Key_blocks_used/(Key_blocks_used + Key_blocks_unused)) * 
100% 

   Key_Buffer_Read_HitRatio=(1-Key_reads/Key_read_requests)*100% 

   Key_Buffer_Write_HitRatio=(1-Key_writes/Key_Write_requests)*100% 

   通过上面的这三个比率数据，就可以很清楚的知道我们的Key Cache设置是否合理，尤其是 
Key_Buffer_Read_HitRatio 参 数 和 Key_buffer_UsageRatio 这 两 个 比 率 。 一 般 来 说 
Key_buffer_UsageRatio应该在99%以上甚至100%，如果该值过低，则说明我们的key_buffer_size设置 
过大，MySQL根本使用不完。Key_Buffer_Read_HitRatio也应该尽可能的高。如果该值较低，则很有可 
能是我们的 key_buffer_size 设置过小，需要适当增加 key_buffer_size 值，也有可能是 
key_cache_age_threshold和key_cache_division_limit的设置不当，造成KeyCachecache失效太快。 
一般来说，在实际应用场景中，很少有人调整key_cache_age_threshold和key_cache_division_limit 
这两个参数的值，大都是使用系统的默认值。 

NULL值对统计信息的影响 
   虽然都是使用B-Tree索引，但是MyISAM索引和Oracle索引的处理方式不太一样，MyISAM的索引中 
是会记录值为NULL的列信息的，只不过NULL值的索引键占用的空间非常少。所以，NULL值的处理方式 
可能会影响到MySQL的查询优化器对执行计划的选择。所以MySQL就给我们提供了myisam_stats_method 
这个参数让我们可以自行决定对索引中的NULL值的处理方式。 

   myisam_stats_method参数的作用就是让我们告诉MyISAM在收集统计信息的时候，是认为所有NULL 
值都是等同还是认为每个NULL值都认为是完全不相等的值，所以其可设置的值也为 nulls_unequal和 
nulls_equal。 

   当我们设置myisam_stats_method= nulls_unequal，MyISAM在搜集统计信息的时候会认为每个 
NULL值都不同，则基于该字段的索引的Cardinality就会更大，也就是说MyISAM会认为DISTINCT值数 

