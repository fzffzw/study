##page 9
4、“.ibd”文件和ibdata 文件
这两种文件都是存放Innodb 数据的文件，之所以有两种文件来存放Innodb 的数据
（包括索引），是因为Innodb 的数据存储方式能够通过配置来决定是使用
共享表空间存放存储数据，还是独享表空间存放存储数据。
独享表空间存储方式使用“.ibd”文件来存放数据，且每个表一个“.ibd”文件，
文件存放在和MyISAM 数据相同的位置。如果选用共享存储表空
间来存放数据，则会使用ibdata 文件来存放，所有表共同使用一个
（或者多个，可自行配置）ibdata 文件。ibdata 文件可以通过innodb_data_home_dir 
和innodb_data_file_path两个参数共同配置组成，
 innodb_data_home_dir 配置数据存放的总目录， 而
innodb_data_file_path 配置每一个文件的名称。当然， 也可以不配置
innodb_data_home_dir 而直接在innodb_data_file_path 参数配置的时候使用绝对路径来
完成配置。innodb_data_file_path 中可以一次配置多个ibdata 文件。文件可以是指定大
小，也可以是自动扩展的，但是Innodb 限制了仅仅只有最后一个ibdata 文件能够配置成自
动扩展类型。当我们需要添加新的ibdata 文件的时候，只能添加在innodb_data_file_path
配置的最后，而且必须重启MySQL 才能完成ibdata 的添加工作。不过如果我们使用独享表
空间存储方式的话，就不会有这样的问题，但是如果要使用裸设备的话，每个表一个裸设备，
可能造成裸设备数量非常大，而且不太容易控制大小，实现比较困难，而共享表空间却不会
有这个问题，容易控制裸设备数量。我个人还是更倾向于使用独享表空间存储方式。当然，
两种方式各有利弊，看大家各自应用环境的侧重点在那里了。
上面仅仅介绍了两种最常用存储引擎的数据文件，此外其他各种存储引擎都有各自的数
据文件，读者朋友可以自行创建某个存储引擎的表做一个简单的测试，做更多的了解。

2.1.3 Replication相关文件
1、master.info 文件：
master.info 文件存在于Slave 端的数据目录下，里面存放了该Slave 的Master 端的
相关信息，包括Master 的主机地址，连接用户，连接密码，连接端口，当前日志位置，已
经读取到的日志位置等信息。

2、relay log 和relay log index
mysql-relay-bin.xxxxxn 文件用于存放Slave 端的I/O 线程从Master 端所读取到
的Binary Log 信息，然后由Slave 端的SQL 线程从该relay log 中读取并解析相应的
日志信息，转化成Master 所执行的SQL 语句，然后在Slave 端应用。
mysql-relay-bin.index 文件的功能类似于mysql-bin.index ，同样是记录日志的存
放位置的绝对路径，只不过他所记录的不是Binary Log，而是Relay Log。
3、relay-log.info 文件：
类似于master.info，它存放通过Slave 的I/O 线程写入到本地的relay log 的相关信
息。供Slave 端的SQL 线程以及某些管理操作随时能够获取当前复制的相关信息。

#p23
另外MyISAM 的B-Tree 索引有一个较
大的限制，那就是参与一个索引的所有字段的长度之和不能超过1000 字节。

MyISAM 的数据存放格式是分为静态（FIXED）固
定长度、动态（DYNAMIC）可变长度以及压缩（COMPRESSED）这三种格式

只要表中有可变长度类型的字段存在，那么该表就肯定是DYNAMIC 格式的，如果没有任何可变长度的字段，
则为FIXED 格式


MyISAM 存储引擎的表是否足够可靠呢？在MySQL 用户参考手册中列出在遇到如下情况
的时候可能会出现表文件损坏：
1、当mysqld 正在做写操作的时候被kill 掉或者其他情况造成异常终止；
2、主机Crash；
3、磁盘硬件故障；
4、MyISAM 存储引擎中的bug？
##检查表
check table api_dhl

READ UNCOMMITTED，
READ COMMITTED，
REPEATABLE READ 
SERIALIZABLE

2、数据多版本读取
Innodb 在事务支持的同时，为了保证数据的一致性已经并发时候的性能，通过对undo
信息，实现了数据的多版本读取。

3、锁定机制的改进
Innodb 改变了MyISAM 的锁机制，实现了行锁。虽然Innodb 的行锁机制的实现是通过
索引来完成的，但毕竟在数据库中99%的SQL 语句都是要使用索引来做检索数据的。所以，
行锁定机制也无疑为Innodb 在承受高并发压力的环境下增强了不小的竞争力


一种是共享表空间，通过innodb_data_file_path 来指定，
另外一种是独享表空间，也就是每个表的数据和索引被存放在一个
单独的.ibd 文件中。

一个参数（skip-innodb）来屏蔽MySQL 中的Innodb
存储引擎，这样即使我们在安装编译的时候将Innodb 存储引擎安装进去了，使用者也无法
创建Innodb 的表


/etc/services

#p52 mysql备份
通过mysqldump 生成INSERT 语句的逻辑备份文件的时候，有一个非常有用的选项可
以供我们使用，那就是“--master-data[=value]”。当添加了“--master-data=1”的时候，
mysqldump 会将当前MySQL 使用到binlog 日志的名称和位置记录到dump 文件中，并且是被
以CHANGE_MASTER 语句的形式记录，如果仅仅只是使用“--master-data”或者“--masterdata＝
2”，则CHANGE_MASTER 语句会以注释的形式存在。这个选项在实施slave 的在线搭建
的时候是非常有用的，即使不是进行在线搭建slave，也可以在某些情况下做恢复的过程中
通过备份的binlog 做进一步恢复操作。
在某些场景下，我们可能只是为了将某些特殊的数据导出到其他数据库中，而又不希望
通过先建临时表的方式来实现，我们还可以在通过mysqldump 程序的“—where='wherecondition'”
来实现，但只能在仅dump 一个表的情况下使用。

，通过“--no-createinfo”
去掉dump 文件中创建表结构的命令等等


通过"FIELDS TERMINATED BY"可以设定每两个字段之间的分隔符；
而通过“LINES TERMINATED BY”则会告诉MySQL 输出文件在每条记录结束的时候需要
添加什么字符。

SELECT * from Table INTO OUTFILE '/tmp/dump.text'
-> FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
-> LINES TERMINATED BY '\n'
-> FROM test_outfile limit 100;

导出逗号的
mysqldump -uroot -T/tmp/mysqldump test test_outfile --fieldsenclosed-
by=\" --fields-terminated-by=,

mysql优化
##p77
MySQL 的 Query Profiler 是一个使用非常方便的 Query 诊断分析工具，
通过该工具可以获取一条Query 在整个执行过程中多种资源的消耗情况，
如 CPU，IO，IPC，SWAP 等，以及发生的 PAGE FAULTS，CONTEXT SWITCHE 等等，
同时还能得到该 Query 执行过程中 MySQL 所调用的各个函数在源文件中的位置。


##p89
锁定类型					说明
IGNORE					当发生锁请求的时候内部交互使用，在锁定结构和队列中并不会有任何信息存储
UNLOCK					释放锁定请求的交互用所类型
READ					普通读锁定
WRITE					普通写锁定
READ_WITH_SHARED_LOCKS  在Innodb 中使用到，由如下方式产生 如：SELECT ... LOCK IN SHARE MODE
READ_HIGH_PRIORITY		高优先级读锁定
READ_NO_INSERT			不允许Concurent Insert 的锁定
WRITE_ALLOW_WRITE		这个类型实际上就是当由存储引擎自行处理锁定的时候，mysqld 允许其他的线程再获取读或者写锁定，因为即使资源冲突，存储引擎自己也会知道怎么来处理
WRITE_ALLOW_READ		这种锁定发生在对表做DDL（ALTER TABLE ...）的时候，MySQL 可以允许其他线程获取读锁定，因为MySQL 是通过重建整个表然后再RENAME 而实现的该功能，所在整个过程原表仍然可以提供读服务
WRITE_CONCURRENT_INSERT 正在进行Concurent Insert 时候所使用的锁定方式，该锁定进行的时候，除了READ_NO_INSERT 之外的其他任何读锁定请求都不会被阻塞
WRITE_DELAYED			在使用INSERT DELAYED 时候的锁定类型
WRITE_LOW_PRIORITY		显示声明的低级别锁定方式， 通过设置LOW_PRIORITY_UPDAT = 1 而产生
WRITE_ONLY				当在操作过程中某个锁定异常中断之后系统内部需要进行CLOSE TABLE 操作，在这个过程中出现的锁定类型就是WRITE_ONLY




###p125
mysql索引限制
1）myisam索引键值的长度不能超过1000字节
2）blob text类型的列目前只支持前缀索引
3）mysql目前不支持函数索引
4）使用！使用无法使用索引
5）过滤字段使用了函数后无法使用索引
6）join条件字段的类型不一致时无法使用索引
7）使用like开始无法使用索引
8)使用非等值mysql无法使用hash索引



