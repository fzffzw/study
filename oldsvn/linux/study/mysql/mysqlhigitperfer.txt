前言 III
第1章：MySQL架构 1
1.1 MySQL的逻辑架构 1
1.2 并发控制 3
1.3 事务 6
1.4 多版本并发控制 12
1.5 MySQL的存储引擎 14
第2章：寻找瓶颈：基准测试（Benchmarking）与性能分析（Profiling） 32
2.1 为什么要进行基准测试 33
2.2 基准测试策略 33
2.3 基准测试工具 42
2.4 基准测试样例 44
2.5 性能分析（Profiling） 54
2.6 分析操作系统 76
第3章：架构优化和索引 80
3.1 选择优化的数据类型 80
3.2 索引基础知识 95
3.3 高性能索引策略 106
3.4 索引实例研究 131
3.5 索引和表维护 136
3.6 正则化和非正则化 139
3.7 加速ALTER TABLE 145
3.8 对存储引擎的说明 149

第4章：查询性能优化 152
4.1 基本原则：优化数据访问 152
4.2 重构查询的方式 157
4.3 查询执行基础知识 160
4.4 MySQL查询优化器的限制 179
4.5 优化特定类型的查询 188
4.6 查询优化提示 195
4.7 用户定义变量 198
第5章：MySQL高级特性 204
5.1 MySQL查询缓存 204
5.2 在MySQL中存储代码 217
5.3 游标 224
5.4 准备语句 225
5.5 用户自定义函数 230
5.6 视图 231
5.7 字符集和排序规则 237
5.8 全文搜索 244
5.9 外键约束 252
5.10 合并表和分区 253
5.11 分布式（XA）事务 262
第6章：优化服务器设置 265
6.1 配置基础知识 266
6.2 通用调优原则 271
6.3 MySQL I/O调优 281
6.4 MySQL并发调优 295
6.5 基于工作负载调优 298
6.6 每联接（Per-Connection）设置调优 304
第7章：操作系统和硬件优化 305
7.1 什么限制了MySQL的性能 306
7.2 如何为MySQL选择CPU 306
7.3 平衡内存和磁盘资源 309
7.4 为从服务器选择硬件 317
7.5 RAID性能优化 317
7.6 存储区域网络和网络附加存储 325
7.7 使用多个磁盘卷 326
7.8 网络配置 328
7.9 选择操作系统 330
7.10 选择文件系统 331
7.11 线程处理 334
7.12 交换 334
7.13 操作系统状态 336
第8章：复制 343
8.1 复制概述 343
8.2 创建复制 347
8.3 揭示复制的真相 355
8.4 复制拓扑 362
8.5 复制和容量规划 376
8.6 复制管理和维护 378
8.7 复制问题和解决方案 388
8.8 复制有多快 405
8.9 MySQL复制的未来 407
第9章：伸缩性与高可用性 409
9.1 术语 410
9.2 MySQL的伸缩性 412
9.3 负载平衡 436
9.4 高可用性 447
第10章：应用层面的优化 457
10.1 应用程序性能概述 457
10.2 Web服务器的议题 460
10.3 缓存 463
10.4 扩展MySQL 470
10.5 可替代的MySQL 471
第11章：备份与还原 472
11.1 概况 473
11.2 要权衡的事项 477
11.3 管理和备份二进制日志 486
11.4 数据备份 488
11.5 从备份中还原 499
11.6 备份和还原的速度 510
11.7 备份工具 511
11.8 脚本化备份 518
第12章：安全 521
12.1 术语 521
12.2 账号的基本知识 522
12.3 操作系统安全 541
12.4 网络安全 542
12.5 数据加密 550
12.6 在Chroot环境里使用MySQL 554
第13章：MySQL服务器的状态 557
13.1 系统变量 557
13.2 SHOW STATUS 558
13.3 SHOW INNODB STATUS 565
13.4 SHOW PROCESSLIST 578
13.5 SHOW MUTEX STATUS 579
13.6 复制的状态 580
13.7 INFORMATION_SCHEMA 581
第14章：用于高性能MySQL的工具 583
14.1 带界面的工具 583
14.2 监控工具 585
14.3 分析工具 595
14.4 MySQL的辅助工具 598
14.5 更多的信息来源 601
附录A：大文件传输 603
附录B：使用EXPLAIN 607
附录C：在MySQL里使用Sphinx 623
附录D：锁的调试 650
索引 659


第1章：MySQL架构 1
1.1 MySQL的逻辑架构 1
1.2 并发控制 3
隔离级别
read uncommited (读取未提交内容)
所有事务可以"看到"未提交的事务执行结果。产生脏读
read commited（读取提交内容）
大多数数据库默认是read commited（这不是mysql默认的）。它满足隔离的早先简单定义：一个事务开始时，只能
"看到"已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的。这种隔离级别支持
所谓的"不可重复读"。意味着用户运行同一语句两次，看到结果是不同的。
repeatable read （可重复读）innodb falcon默认这种设置
产生幻读，幻读指用户读取某一范围的数据行时，另一事务又在该范围内插入新行，当用户在读改范围数据时，
会发现有新的”幻影“行。
serializable （可串行化）

1 #可选参数有：READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.
2 [mysqld]
3 transaction-isolation = REPEATABLE-READ

select @@TX_ISOLATION

select @@global.tx_isolation,@@tx_isolation;



1.脏读

允许读取到未提交的脏数据。

2.不可重复读
如果你在时间点T1读取了一些记录，在T2时再想重新读取一次同样的这些记录时，这些记录可能已经被改变、
或者消失不见。

3.幻读
解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。
但是，如果另一个事务同时提交了新数据，本事务再更新时，就会“惊奇的”发现了这些新数据，
貌似之前读到的数据是“鬼影”一样的幻觉。


mysql 用set session transaction isolation level read commited;
隐式和显示锁定
Innodb使用二相锁定协议。一个事务在执行过程中任何时候，都可以获得锁，
但只有执行commit或者rollback是才可以释放这些锁，
1.3 事务 6
1.4 多版本并发控制 12
大多数存储引擎，如InnoDB、Falcon、PBXT不是简单地使用行加锁机制，二十选用多版本并发控制（MVCC，Multiversion concurrency control）
的技术，和行加锁关联使用。它可以在读取期间锁定需要的记录同时，还允许非锁定的读取。
MVCC通过及时保存某些时刻的数据快照，得意实现，同一事务多个实例，同时允许，看到数据视图，同一时间，对用一个表，不同事务看到数据
却是不同的！
InnoDB通过为每个数据行增加两个隐含的值来实现MVCC，这两个值，记录行创建时间，已经它过期时间。
每一行都存储了事件发生时的系统版本号（System version number），用来替代事件发生时的实际时间。
每一次开始新的事务时，版本号都会自动递增。每个事务保存它在开始时"当前系统版本"的记录，每个查询都会根据事务
的版本号，检查每行的数据版本号。

例如下面
select 
	InnoDB检查每行的数据，确保符合两个标准
	1）InnoDB只查找早于当前事务版本的数据行，者保留当前事务读取的行都是事务开始前已经存在，或者是当前事务创建或修改的行
	2）数据行删除版本必须未定义，保证事务读取的行，在事务开始是未被删除的。
	Insert
	InnoDB为每个新增的行记录当前版本号
	delete
	InnoDB为个删除行记录当前版本号，作为行删除标识。
	update
	InnoDB会为每个需要更新的行，建立一个新的行拷贝，并且为新的行拷贝，记录当前的系统版本号。同时
	也为更新前的旧行，记录系统的版本号，作为旧行删除版本标识。
	
	MVCC只工作在repeatable read 和read commited两个隔离级别
	

1.5 MySQL的存储引擎 14
show table status like 'ftp_message_shipbatch_order'

Row_format
对于myIsam表，可能是dynamic、Fixed、或者Compressed。

InnoDB引擎

